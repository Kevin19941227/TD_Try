<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phaser 3.90｜煙 / 水 / 沙（逐球）＋ 粒子尾巴 + 風偏筆跡</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #0b1020; color: #ecf0ff; font-family: Inter, Noto Sans TC, system-ui; }
    #game { position: fixed; inset: 0 }
    .panel {
      position: fixed; right: 12px; top: 12px; width: 340px; max-height: calc(100vh - 24px);
      background: rgba(16,22,53,.75); backdrop-filter: blur(10px);
      border: 1px solid rgba(34,211,238,.45); border-radius: 16px; padding: 14px; overflow: auto;
      box-shadow: 0 10px 30px rgba(0,0,0,.35)
    }
    h2 { margin: 0 0 10px; font-size: 16px }
    .row { display: grid; grid-template-columns: 110px 1fr 60px; gap: 8px; align-items: center; margin: 6px 0 }
    .mode-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 6px 0 10px }
    .btn { cursor: pointer; background: #1e2a5a; border: 1px solid #33457a; color: #ecf0ff; padding: 6px 10px; border-radius: 10px }
    .btn:hover { background: #26316b }
    .swatch { width: 24px; height: 24px; border-radius: 8px; border: 1px solid rgba(255,255,255,.35) }
    .sep { height: 1px; background: linear-gradient(90deg,transparent,rgba(255,255,255,.25),transparent); margin: 10px 0 }
    .subtle { color: #a5b4fc; font-size: 12px }
    input[type="range"] { width: 100% }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px }
    .groupTitle { margin-top: 8px; font-weight: 600; font-size: 13px; color: #c7d2fe }
  </style>
</head>
<body>
  <div id="game"></div>

  <div class="panel">
    <h2>生成材質（逐球）</h2>
    <div class="mode-row">
      <label><input type="radio" name="matSpawn" value="sand" checked> 流沙</label>
      <label><input type="radio" name="matSpawn" value="water"> 水流</label>
      <label><input type="radio" name="matSpawn" value="smoke"> 煙霧</label>
    </div>

    <div class="sep"></div>
    <div class="subtle">顏色（HSB 範圍，影響新球）</div>
    <div class="row"><label>Hue 低</label><input type="range" id="hMin" min="0" max="360" value="28"><output id="hMinOut">28</output></div>
    <div class="row"><label>Hue 高</label><input type="range" id="hMax" min="0" max="360" value="48"><output id="hMaxOut">48</output></div>
    <div class="row"><label>Sat 低</label><input type="range" id="sMin" min="0" max="100" value="45"><output id="sMinOut">45%</output></div>
    <div class="row"><label>Sat 高</label><input type="range" id="sMax" min="0" max="100" value="90"><output id="sMaxOut">90%</output></div>
    <div class="row"><label>Bri 低</label><input type="range" id="bMin" min="0" max="100" value="60"><output id="bMinOut">60%</output></div>
    <div class="row"><label>Bri 高</label><input type="range" id="bMax" min="0" max="100" value="95"><output id="bMaxOut">95%</output></div>

    <div class="sep"></div>
    <div class="grid2">
      <button class="btn" id="spawn10">新增 20 顆</button>
      <button class="btn" id="clear">清空</button>
    </div>
    <div class="mode-row" style="margin-top:8px">
      <span class="subtle">示意色：</span>
      <div class="swatch" id="swatch"></div>
    </div>

    <div class="sep"></div>
    <div class="groupTitle">尾巴尺寸</div>
    <div class="row">
      <label>尾巴基準</label>
      <input type="range" id="baseScale" min="1" max="100" step="1" value="20">
      <output id="baseScaleOut">20</output>
    </div>

    <div class="sep"></div>
    <div class="groupTitle">筆跡（風偏）參數</div>
    <div class="row"><label>風力增益</label><input type="range" id="windGain" min="0" max="0.4" step="0.01" value="0.14"><output id="windGainOut">0.14</output></div>
    <div class="row"><label>風阻尼</label><input type="range" id="windDrag" min="0.70" max="0.98" step="0.01" value="0.86"><output id="windDragOut">0.86</output></div>
    <div class="row"><label>橫向弧度</label><input type="range" id="cross" min="0" max="0.6" step="0.01" value="0.28"><output id="crossOut">0.28</output></div>
    <div class="row"><label>最大偏移(px)</label><input type="range" id="maxWind" min="0" max="120" step="1" value="60"><output id="maxWindOut">60</output></div>
    <div class="row"><label>雜訊擺幅</label><input type="range" id="noiseAmp" min="0" max="1.2" step="0.05" value="0.60"><output id="noiseAmpOut">0.60</output></div>

    <div class="sep"></div>
    <div class="groupTitle">筆跡產生</div>
    <div class="row"><label>間距(px)</label><input type="range" id="spacing" min="8" max="60" step="1" value="24"><output id="spacingOut">24</output></div>
    <div class="row"><label>頻率(s)</label><input type="range" id="interval" min="0.02" max="0.2" step="0.01" value="0.10"><output id="intervalOut">0.10</output></div>
    <div class="row"><label>每次上限</label><input type="range" id="maxPerTick" min="1" max="12" step="1" value="7"><output id="maxPerTickOut">7</output></div>

    <div class="sep"></div>
    <div class="subtle">
      左鍵新增球（用目前材質）；<br />
      拖曳＝筆跡（含風偏）；<br />
      右鍵點球＝切材質；<br />
      <b>Shift+右鍵</b>點球＝改該顆顏色；<br />
      <b>滑鼠滾輪</b>指著球＝改該顆尺寸；P 暫停。
    </div>
  </div>

  <script>
    /* ===== 小工具 ===== */
    function HSBtoRGB(h, s, v) {
      const c = v * s, x = c * (1 - Math.abs(((h / 60) % 2) - 1)), m = v - c;
      let r = 0, g = 0, b = 0;
      if (h < 60) { r = c; g = x; b = 0 }
      else if (h < 120) { r = x; g = c; b = 0 }
      else if (h < 180) { r = 0; g = c; b = x }
      else if (h < 240) { r = 0; g = x; b = c }
      else if (h < 300) { r = x; g = 0; b = c }
      else { r = c; g = 0; b = x }
      return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
    }
    const RGBhex = (r, g, b) => (r << 16) + (g << 8) + b;
    const ri = (a, b) => Math.floor(a + Math.random() * (b - a + 1));
    const rf = (a, b) => a + Math.random() * (b - a);

    /* ===== 狀態 ===== */
    const state = {
      spawnMaterial: 'sand',
      hMin: 28, hMax: 48, sMin: .45, sMax: .90, bMin: .60, bMax: .95,
      baseScale: 20  // 尾巴粒子基準（1–100）
    };

    /* ===== 三種材質（逐球邏輯 + 尾巴設定） ===== */
    const Materials = {
      sand: {
        label: '流沙', texture: 'dot64',
        applyPreset(body, sprite) {
          sprite.setAlpha(1).setBlendMode(Phaser.BlendModes.NORMAL);
          body.setBounce(0.15);
          body.setDrag(160, 180);
          body.setVelocity(ri(-20, 20), ri(20, 60));
          body.setMass(1.3);
          body._mat = 'sand';
        },
        tick(scene, body, dt) {
          const jitter = 6;
          body.velocity.x += Phaser.Math.FloatBetween(-jitter, jitter) * (dt / 16.7);
          if (body.velocity.length() < 20) body.velocity.y += 12 * (dt / 16.7);
          const max = 220;
          if (body.velocity.length() > max) body.velocity.scale(max / body.velocity.length());
        },
        trailCfg(sprite) {
          return {
            blendMode: 'NORMAL',
            alpha: { start: 0.55, end: 0 },
            // scale 會在 attachOrRefreshTrail 裡覆蓋
            speed: { min: 20, max: 70 },
            lifespan: { min: 420, max: 800 },
            gravityY: 280,
            frequency: 40,
            quantity: 1,
            tint: sprite.tintTopLeft
          };
        }
      },
      water: {
        label: '水流', texture: 'soft64',
        applyPreset(body, sprite) {
          sprite.setAlpha(0.8).setBlendMode(Phaser.BlendModes.ADD);
          body.setBounce(1);
          body.setDrag(18, 18);
          body.setVelocity(ri(-90, 90), ri(-90, 90));
          body.setMass(1.0);
          body._ox = Math.random() * 1000; body._oy = Math.random() * 1000;
          body._mat = 'water';
        },
        tick(scene, body, dt) {
          const t = scene.time.now * 0.0005;
          const nx = Math.sin(t + (body._ox || 0));
          const ny = Math.cos(t * 0.9 + (body._oy || 0));
          const speed = 120;
          const tx = nx * speed, ty = ny * speed;
          body.velocity.x += (tx - body.velocity.x) * 0.12;
          body.velocity.y += (ty - body.velocity.y) * 0.12;
          const jitter = 6;
          body.velocity.x += Phaser.Math.FloatBetween(-jitter, jitter) * (dt / 16.7);
          body.velocity.y += Phaser.Math.FloatBetween(-jitter, jitter) * (dt / 16.7);
          const max = 150;
          if (body.velocity.length() > max) body.velocity.scale(max / body.velocity.length());
        },
        trailCfg(sprite) {
          return {
            blendMode: 'ADD',
            alpha: { start: 0.6, end: 0 },
            speed: { min: 40, max: 100 },
            lifespan: { min: 360, max: 720 },
            gravityY: 0,
            frequency: 35,
            quantity: 1,
            tint: sprite.tintTopLeft
          };
        }
      },
      smoke: {
        label: '煙霧', texture: 'soft64',
        applyPreset(body, sprite) {
          sprite.setAlpha(0.55).setBlendMode(Phaser.BlendModes.SCREEN);
          body.setBounce(0);
          body.setDrag(90, 130);
          body.setVelocity(ri(-25, 25), ri(-10, 15));
          body.setMass(0.85);
          body._spin = (Math.random() * 0.6 + 0.2) * (Math.random() < .5 ? -1 : 1);
          body._mat = 'smoke';
          sprite._targetScale = sprite.scale * (1.1 + Math.random() * 0.25);
        },
        tick(scene, body, dt) {
          body.velocity.y -= 10 * (dt / 16.7);
          const jitter = 4;
          body.velocity.x += Phaser.Math.FloatBetween(-jitter, jitter) * (dt / 16.7);
          body.velocity.y += Phaser.Math.FloatBetween(-jitter, jitter) * (dt / 16.7);
          const max = 120;
          if (body.velocity.length() > max) body.velocity.scale(max / body.velocity.length());
          const s = body.gameObject;
          if (s) {
            const k = 1 + 0.04 * (dt / 1000);
            s.setScale(Math.min(s._targetScale || s.scale, s.scale * k));
            s.rotation += (body._spin || 0) * (dt / 1000);
            const base = 0.475, amp = 0.125;
            const tt = scene.time.now * 0.001 + (body._ox || 0);
            s.setAlpha(Phaser.Math.Clamp(base + Math.sin(tt) * amp, 0.2, 0.7));
          }
        },
        trailCfg(sprite) {
          return {
            blendMode: 'SCREEN',
            alpha: { start: 0.35, end: 0 },
            speed: { min: 10, max: 28 },
            lifespan: { min: 900, max: 1500 },
            gravityY: -12,
            frequency: 55,
            quantity: 1,
            tint: sprite.tintTopLeft,
            rotate: { min: -10, max: 10 }
          };
        }
      }
    };

    /* ===== 場景 ===== */
    class FXScene extends Phaser.Scene {
      constructor() { super('FXScene'); }
      preload() {
        // 主球貼圖：實心與羽化
        const g = this.make.graphics({ x: 0, y: 0, add: false });
        g.clear(); g.fillStyle(0xffffff, 1); g.fillCircle(32, 32, 32); g.generateTexture('dot64', 64, 64);
        g.clear();
        for (let r = 30; r >= 0; r--) { g.fillStyle(0xffffff, (1 - r / 30) * 0.08 + 0.05); g.fillCircle(32, 32, r); }
        g.generateTexture('soft64', 64, 64);
        // 粒子貼圖（更小，省繪製）
        g.clear();
        for (let r = 7; r >= 0; r--) { g.fillStyle(0xffffff, (1 - r / 7) * 0.12 + 0.08); g.fillCircle(8, 8, r); }
        g.generateTexture('soft16', 16, 16);
        g.destroy();
      }

      create() {
        const W = this.scale.width, H = this.scale.height;
        this.physics.world.setBounds(0, 0, W, H, true, true, true, true);
        this.physics.world.gravity.y = 0;

        this.balls = this.add.group();
        this._drawGridBG();

        for (let i = 0; i < 110; i++) this.spawnBall();

        // 🆕 筆跡狀態
        this.brush = {
          active: false,
          anchor: { x: 0, y: 0 },
          acc: 0,
          interval: 100,   // ms
          spacing: 24,     // px
          maxPerTick: 7,
          wind: { x: 0, y: 0 },
          windGain: 0.14,
          windDrag: 0.86,
          cross: 0.28,
          maxWind: 60,
          noiseAmp: 0.60
        };

        // 指標採樣用（估算滑鼠速度）
        this._ptr = { inited: false, x: 0, y: 0 };

        // 左鍵：點一下新增 + 開筆
        this.input.on('pointerdown', p => {
          if (p.rightButtonDown()) return;
          for (let i = 0; i < 5; i++) this.spawnBall(p.worldX, p.worldY);
          this.brush.active = true;
          this.brush.anchor.x = p.worldX;
          this.brush.anchor.y = p.worldY;
          this.brush.acc = 0;
        });

        // 右鍵：切材質；Shift+右鍵：改色
        this.input.mouse.disableContextMenu();
        this.input.on('pointerdown', p => {
          if (!p.rightButtonDown()) return;
          const s = this.physics.closest(p, this.balls.getChildren());
          if (!s) return;
          if (p.event.shiftKey) { this.recolorBall(s); this.updateTrailTint(s); }
          else {
            const body = s.body;
            const next = body._mat === 'sand' ? 'water' : (body._mat === 'water' ? 'smoke' : 'sand');
            this.applyMaterial(s, next, true);
          }
        });

        this.input.on('pointermove', p => { if (p.isDown && !p.rightButtonDown()) this.brush.active = true; });
        this.input.on('pointerup', p => {
          if (!p.rightButtonDown()) {
            this.brush.active = false;
            // 收筆時把幾何錨點更新到當前位置，避免下一次一開始拉很長
            this.brush.anchor.x = p.worldX;
            this.brush.anchor.y = p.worldY;
          }
        });

        // 滾輪：尺寸
        this.input.on('wheel', (pointer, over, dx, dy, dz, event) => {
          const s = this.physics.closest(pointer, this.balls.getChildren());
          if (!s) return;
          const delta = -Math.sign(dy) * 0.08;
          this.resizeBall(s, Phaser.Math.Clamp(s.scale + delta, 0.25, 1.35));
          event.preventDefault();
        });

        // Info
        this.info = this.add.text(12, 12, '', {
          fontFamily: 'Inter, Noto Sans TC, system-ui', fontSize: '14px', color: '#ecf0ff'
        }).setDepth(1000);

        this.input.keyboard.on('keydown-P', () => {
          this.physics.world.isPaused ? this.physics.world.resume() : this.physics.world.pause();
        });

        this.scale.on('resize', ({ width, height }) => {
          this.cameras.main.setSize(width, height);
          this.physics.world.setBounds(0, 0, width, height, true, true, true, true);
        });
      }

      spawnBall(x, y) {
        const W = this.scale.width, H = this.scale.height;
        const radius = ri(7, 16);
        const h = ri(state.hMin, state.hMax), s = rf(state.sMin, state.sMax), v = rf(state.bMin, state.bMax);
        const { r, g, b } = HSBtoRGB(h, s, v); const tint = RGBhex(r, g, b);
        const key = Materials[state.spawnMaterial].texture;
        const spr = this.add.image(x ?? ri(radius, W - radius), y ?? ri(radius, H - radius), key)
          .setTint(tint).setScale(radius / 32);
        this.physics.add.existing(spr);
        const body = spr.body;

        // ✅ 碰撞半徑與可視一致
        const rad = 32 * spr.scale;
        const off = 32 - rad;
        body.setCircle(rad, off, off).setCollideWorldBounds(true);

        // 材質 + 尾巴
        this.applyMaterial(spr, state.spawnMaterial, true);

        // 互相碰撞
        this.balls.add(spr);
        this.balls.children.iterate(o => { if (o && o !== spr) this.physics.add.collider(spr, o); });

        spr.on('destroy', () => { if (spr._emit) { spr._emit.destroy(); spr._emit = null; } });
      }

      applyMaterial(spr, mat, refreshTrail = false) {
        const body = spr.body;
        spr.setTexture(Materials[mat].texture);
        spr.setAlpha(1).setBlendMode(Phaser.BlendModes.NORMAL);
        body.setBounce(0).setDrag(0, 0);
        delete body._ox; delete body._oy; delete body._spin;
        Materials[mat].applyPreset(body, spr);
        if (refreshTrail) this.attachOrRefreshTrail(spr, mat);
      }

      recolorBall(spr) {
        const h = ri(state.hMin, state.hMax), s = rf(state.sMin, state.sMax), v = rf(state.bMin, state.bMax);
        const { r, g, b } = HSBtoRGB(h, s, v);
        spr.setTint(RGBhex(r, g, b));
        this.updateTrailTint(spr);
      }

      updateTrailTint(spr) { if (spr._emit) spr._emit.setTint(spr.tintTopLeft); }

      resizeBall(spr, newScale) {
        spr.setScale(newScale);
        const radius = 32 * newScale;
        const offset = 32 - radius;
        spr.body.setCircle(radius, offset, offset);
        // 同步尾巴大小（使用 baseScale）
        if (spr._emit) {
          const baseScale = state.baseScale * spr.scale;
          spr._emit.setConfig({ scale: { start: baseScale, end: baseScale * 0.5 } });
        }
      }

      attachOrRefreshTrail(spr, mat) {
        if (spr._emit) { spr._emit.destroy(); spr._emit = null; }
        const cfg = Materials[mat].trailCfg(spr);

        // ✅ 讓尾巴粒子大小 = 全域基準 * 球尺度
        const baseScale = state.baseScale * spr.scale;
        cfg.scale = { start: baseScale, end: baseScale * 0.5 };

        const e = this.add.particles(0, 0, 'soft16', {
          on: true,
          follow: spr,
          followOffset: { x: 0, y: 0 },
          ...cfg
        });
        e.setDepth((spr.depth ?? 0) - 1);
        e.setScrollFactor(spr.scrollFactorX ?? 1, spr.scrollFactorY ?? 1);
        spr._emit = e;
      }

      clearBalls() {
        this.balls.children.iterate(s => { if (s && s._emit) { s._emit.destroy(); s._emit = null; } });
        this.physics.world.colliders.destroy();
        this.balls.clear(true, true);
      }

      update(t, dt) {
        const fps = (1000 / dt) | 0;
        this.info.setText([`Balls: ${this.balls.getLength()}`, `FPS: ${fps}`]);

        // 物理行為
        this.balls.children.iterate(s => {
          const b = s.body; const m = b._mat || 'sand';
          Materials[m].tick(this, b, dt);
        });

        // === 先更新風偏 ===
        const p = this.input.activePointer;
        const dtSec = dt / 1000;
        let vx = 0, vy = 0;
        if (this._ptr.inited) {
          vx = (p.worldX - this._ptr.x) / (dtSec || 1/60);
          vy = (p.worldY - this._ptr.y) / (dtSec || 1/60);
        } else { this._ptr.inited = true; }
        this._ptr.x = p.worldX; this._ptr.y = p.worldY;

        const br = this.brush;
        const tnow = this.time.now * 0.001;
        const noiseX = Math.sin(tnow * 3.1) * br.noiseAmp;
        const noiseY = Math.cos(tnow * 2.7) * br.noiseAmp;
        const fx = vx * br.windGain + (-vy) * br.cross * br.windGain + noiseX;
        const fy = vy * br.windGain + ( vx) * br.cross * br.windGain + noiseY;
        br.wind.x = br.wind.x * br.windDrag + fx * dtSec;
        br.wind.y = br.wind.y * br.windDrag + fy * dtSec;
        const wmag = Math.hypot(br.wind.x, br.wind.y);
        if (wmag > br.maxWind) { const k = br.maxWind / (wmag || 1); br.wind.x *= k; br.wind.y *= k; }

        // === 再依最新風偏做筆跡鋪球 ===
        if (br.active) {
          br.acc += dt;
          if (br.acc >= br.interval) {
            br.acc -= br.interval;

            const px = p.worldX, py = p.worldY;
            let ax = br.anchor.x + br.wind.x;
            let ay = br.anchor.y + br.wind.y;
            const dx = px - ax, dy = py - ay;
            const dist = Math.hypot(dx, dy);

            if (dist >= br.spacing) {
              const dirx = dx / dist, diry = dy / dist;
              let placed = 0, traveled = 0;
              while (traveled + br.spacing <= dist && placed < br.maxPerTick) {
                traveled += br.spacing;
                const x = ax + dirx * traveled;
                const y = ay + diry * traveled;
                this.spawnBall(x, y);
                placed++;
              }
              if (placed > 0) {
                br.anchor.x = ax - br.wind.x + dirx * traveled;
                br.anchor.y = ay - br.wind.y + diry * traveled;
              }
            }
          }
        }
      }

      _drawGridBG() {
        const W = this.scale.width, H = this.scale.height;
        const g = this.add.graphics().setDepth(-1); g.fillStyle(0x0b1020, 1); g.fillRect(0, 0, W, H);
        g.lineStyle(1, 0x1a2244, 0.5);
        for (let x = 0; x <= W; x += 32) g.lineBetween(x, 0, x, H);
        for (let y = 0; y <= H; y += 32) g.lineBetween(0, y, W, y);
        const border = this.add.graphics().setDepth(999);
        border.lineStyle(2, 0x22d3ee, 0.85); border.strokeRect(1, 1, W - 2, H - 2);
        this.scale.on('resize', ({ width, height }) => {
          g.clear(); g.fillStyle(0x0b1020, 1); g.fillRect(0, 0, width, height);
          g.lineStyle(1, 0x1a2244, 0.5);
          for (let x = 0; x <= width; x += 32) g.lineBetween(x, 0, x, height);
          for (let y = 0; y <= height; y += 32) g.lineBetween(0, y, width, y);
          border.clear(); border.lineStyle(2, 0x22d3ee, 0.85); border.strokeRect(1, 1, width - 2, height - 2);
        });
      }
    }

    /* 啟動 */
    const game = new Phaser.Game({
      type: Phaser.AUTO,
      parent: 'game',
      backgroundColor: '#0b1020',
      scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
      scene: [FXScene]
    });

    /* ===== 讓滑桿能即時更新所有尾巴 ===== */
    function refreshAllTrails() {
      const s = game.scene.keys['FXScene'];
      if (!s || !s.balls) return;
      s.balls.children.iterate(o => {
        if (!o) return;
        const spr = o;
        if (spr._emit) {
          const baseScale = state.baseScale * spr.scale;
          spr._emit.setConfig({ scale: { start: baseScale, end: baseScale * 0.5 } });
        }
      });
    }

    /* ===== UI 綁定 ===== */
    const $ = id => document.getElementById(id);
    const swatch = $('swatch');
    const els = {
      hMin: $('hMin'), hMax: $('hMax'), sMin: $('sMin'), sMax: $('sMax'), bMin: $('bMin'), bMax: $('bMax'),
      hMinOut: $('hMinOut'), hMaxOut: $('hMaxOut'), sMinOut: $('sMinOut'), sMaxOut: $('sMaxOut'), bMinOut: $('bMinOut'), bMaxOut: $('bMaxOut'),
      baseScale: $('baseScale'), baseScaleOut: $('baseScaleOut'),
      windGain: $('windGain'), windGainOut: $('windGainOut'),
      windDrag: $('windDrag'), windDragOut: $('windDragOut'),
      cross: $('cross'), crossOut: $('crossOut'),
      maxWind: $('maxWind'), maxWindOut: $('maxWindOut'),
      noiseAmp: $('noiseAmp'), noiseAmpOut: $('noiseAmpOut'),
      spacing: $('spacing'), spacingOut: $('spacingOut'),
      interval: $('interval'), intervalOut: $('intervalOut'),
      maxPerTick: $('maxPerTick'), maxPerTickOut: $('maxPerTickOut'),
    };

    function clampPair(a, b, lo, hi) {
      if (+a.value > +b.value) { const t = a.value; a.value = b.value; b.value = t; }
      a.value = Math.max(lo, Math.min(+a.value, hi)); b.value = Math.max(lo, Math.min(+b.value, hi));
    }

    function updateHSB() {
      clampPair(els.hMin, els.hMax, 0, 360); clampPair(els.sMin, els.sMax, 0, 100); clampPair(els.bMin, els.bMax, 0, 100);
      state.hMin = +els.hMin.value; state.hMax = +els.hMax.value;
      state.sMin = +els.sMin.value / 100; state.sMax = +els.sMax.value / 100;
      state.bMin = +els.bMin.value / 100; state.bMax = +els.bMax.value / 100;
      els.hMinOut.textContent = els.hMin.value; els.hMaxOut.textContent = els.hMax.value;
      els.sMinOut.textContent = els.sMin.value + '%'; els.sMaxOut.textContent = els.sMax.value + '%';
      els.bMinOut.textContent = els.bMin.value + '%'; els.bMaxOut.textContent = els.bMax.value + '%';
      const { r, g, b } = HSBtoRGB(ri(state.hMin, state.hMax), rf(state.sMin, state.sMax), rf(state.bMin, state.bMax));
      swatch.style.background = `rgb(${r},${g},${b})`;
    }
    [els.hMin, els.hMax, els.sMin, els.sMax, els.bMin, els.bMax].forEach(e => e.addEventListener('input', updateHSB));
    updateHSB();

    // 風場滑桿
    function bindBrushSliders() {
      const s = game.scene.keys['FXScene']; if (!s) return;
      const br = s.brush;

      els.windGain.addEventListener('input', e => { br.windGain = +e.target.value; els.windGainOut.textContent = e.target.value; });
      els.windDrag.addEventListener('input', e => { br.windDrag = +e.target.value; els.windDragOut.textContent = e.target.value; });
      els.cross.addEventListener('input', e => { br.cross = +e.target.value; els.crossOut.textContent = e.target.value; });
      els.maxWind.addEventListener('input', e => { br.maxWind = +e.target.value; els.maxWindOut.textContent = e.target.value; });
      els.noiseAmp.addEventListener('input', e => { br.noiseAmp = +e.target.value; els.noiseAmpOut.textContent = e.target.value; });

      els.spacing.addEventListener('input', e => { br.spacing = +e.target.value; els.spacingOut.textContent = e.target.value; });
      els.interval.addEventListener('input', e => { br.interval = Math.round(+e.target.value * 1000); els.intervalOut.textContent = (+e.target.value).toFixed(2); });
      els.maxPerTick.addEventListener('input', e => { br.maxPerTick = +e.target.value; els.maxPerTickOut.textContent = e.target.value; });

      // 🆕 baseScale：全域尾巴尺寸
      els.baseScale.addEventListener('input', e => {
        state.baseScale = +e.target.value;
        els.baseScaleOut.textContent = e.target.value;
        refreshAllTrails(); // 立即更新所有既有尾巴
      });

      // 初始化 output 顯示
      els.windGainOut.textContent = els.windGain.value;
      els.windDragOut.textContent = els.windDrag.value;
      els.crossOut.textContent = els.cross.value;
      els.maxWindOut.textContent = els.maxWind.value;
      els.noiseAmpOut.textContent = els.noiseAmp.value;
      els.spacingOut.textContent = els.spacing.value;
      els.intervalOut.textContent = (+els.interval.value).toFixed(2);
      els.maxPerTickOut.textContent = els.maxPerTick.value;
      els.baseScaleOut.textContent = els.baseScale.value;
    }

    document.querySelectorAll('input[name="matSpawn"]').forEach(r => {
      r.addEventListener('change', e => { state.spawnMaterial = e.target.value; });
    });

    $('spawn10').addEventListener('click', () => {
      const s = game.scene.keys['FXScene']; for (let i = 0; i < 20; i++) s.spawnBall();
    });
    $('clear').addEventListener('click', () => {
      const s = game.scene.keys['FXScene']; s.clearBalls();
    });

    // 等場景建好再綁滑桿
    window.addEventListener('load', () => {
      const check = setInterval(() => {
        const s = game.scene.keys['FXScene'];
        if (s) { clearInterval(check); bindBrushSliders(); }
      }, 50);
    });
  </script>
</body>
</html>
